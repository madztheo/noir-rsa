use dep::biguint::{BigUint56, MAX_BYTES};
use dep::std::println;
use dep::std::hash::sha256;

pub fn verify_sha256_pkcs1v15(
    msg_hash: [u8; 32],
    sig: BigUint56,
    pubkey_e: BigUint56,
    pubkey_n: BigUint56
) -> bool {
    let padded_sha256_hash = sig.powmod(pubkey_e, pubkey_n);
    compare_signature_sha256(padded_sha256_hash.to_bytes(), msg_hash, sig.to_bytes())
}

// Compares MAX_BYTES byte padded sha256 hash to the 32 byte message hash returned from SHA256
fn compare_signature_sha256(
    padded_sha256_hash: [u8; MAX_BYTES],
    msg_hash: [u8; 32],
    sig: [u8; MAX_BYTES]
) -> bool {
    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)
    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32
    let mut sig_len = 0 as u32;
    let mut sum = 0 as u32;
    for i in 0..MAX_BYTES {
        sum += sig[MAX_BYTES - 1 - i] as u32;
        if sum == 0 {
            sig_len = MAX_BYTES as u32 - 1 - i as u32;
        }
    }

    for i in 0..32 {
        // Padded hash is reversed
        assert(padded_sha256_hash[31 - i] == msg_hash[i]);
    }

    let hash_prefix: [u8; 19] = [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];

    for i in 32..51 {
        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);
    }

    assert(padded_sha256_hash[51] == 0);

    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0
    let ps_len = sig_len - 54;
    for i in 52..MAX_BYTES {
        if i as u32 < 52 + ps_len as u32 {
            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding
            assert(padded_sha256_hash[i] == 255);
        } else if i as u32 == 52 + ps_len as u32 {
            // Pad 0x01
            assert(padded_sha256_hash[i] == 1);
        } else if i as u32 == 53 + ps_len as u32 {
            // 0x00
            assert(padded_sha256_hash[i] == 0);
        } else {
            // Padded with 0 until MAX_BYTES
            assert(padded_sha256_hash[i] == 0);
        }
    }

    true
}

#[test]
fn test_compare_signature_sha256_512() {
    // 64 bytes = 512 bit RSA
    let padded_sha256_hash: [u8; 518] = [
        // Padded hash
        209, 50, 135, 178, 4, 155, 190, 229, 228, 111, 61, 174, 8, 49, 48, 116, 90, 226, 77, 7, 111, 27, 19, 113, 154, 48, 138, 136, 138, 15, 230, 132, 32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49,
        48, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 0,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0
    ];
    // This is be, so need to reverse in the padding check
    let msg_hash: [u8; 32] = [
        132, 230, 15, 138, 136, 138, 48, 154, 113, 19, 27, 111, 7, 77, 226, 90, 116, 48, 49, 8, 174, 61, 111, 228, 229, 190, 155, 4, 178, 135, 50, 209
    ];
    // Values arent used in computation, 64 bytes + rest padding
    let sig: [u8; 518] = [
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0
    ];

    assert(compare_signature_sha256(padded_sha256_hash, msg_hash, sig));
}

#[test]
fn test_compare_signature_sha256_1024() {
    // 128 bytes = 1024 bit RSA
    let padded_sha256_hash: [u8; 518] = [
        // Padded hash
        209, 50, 135, 178, 4, 155, 190, 229, 228, 111, 61, 174, 8, 49, 48, 116, 90, 226, 77, 7, 111, 27, 19, 113, 154, 48, 138, 136, 138, 15, 230, 132, 32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49,
        48, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 0,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];
    // This is be, so need to reverse in the padding check
    let msg_hash: [u8; 32] = [
        132, 230, 15, 138, 136, 138, 48, 154, 113, 19, 27, 111, 7, 77, 226, 90, 116, 48, 49, 8, 174, 61, 111, 228, 229, 190, 155, 4, 178, 135, 50, 209
    ];
    // Values arent used in computation, 128 bytes + rest padding
    let sig: [u8; 518] = [
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];

    assert(compare_signature_sha256(padded_sha256_hash, msg_hash, sig));
}

#[test]
fn test_compare_signature_sha256_2048() {
    // 256 bytes = 2048 bit RSA
    let padded_sha256_hash: [u8; 518] = [
        // Padded hash
        209, 50, 135, 178, 4, 155, 190, 229, 228, 111, 61, 174, 8, 49, 48, 116, 90, 226, 77, 7, 111, 27, 19, 113, 154, 48, 138, 136, 138, 15, 230, 132, 32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49,
        48, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 1, 0,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];
    // This is be, so need to reverse in the padding check
    let msg_hash: [u8; 32] = [
        132, 230, 15, 138, 136, 138, 48, 154, 113, 19, 27, 111, 7, 77, 226, 90, 116, 48, 49, 8, 174, 61, 111, 228, 229, 190, 155, 4, 178, 135, 50, 209
    ];
    // Values arent used in computation, 256 bytes + rest padding
    let sig: [u8; 518] = [
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 2, 3, 4, 5, 1, 1, 1, 0, 1,
        // Rest is padded with 0s until max bytes
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    ];

    assert(compare_signature_sha256(padded_sha256_hash, msg_hash, sig));
}

#[test]
fn test_hash_to_biguint56() {
    // About ready south environment second finally. Work agency determine chance mean serve.
    let msg: [u8] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 32, 84, 104, 105, 115, 32, 105, 115, 32, 78, 111, 105, 114, 45, 82, 83, 65];
    let hash = sha256(msg);
    println(hash);
    let hash_biguint = BigUint56::from_sha256_hash(hash);
    println(hash_biguint.limbs);

    let mut sha256_hash = [0 as u8; 32];
    for i in 0..32 {
        // Reverse
        sha256_hash[i] = hash_biguint.to_bytes()[31 - i];
    }
    println(sha256_hash);
}

#[test]
fn test_verify_sha256_pkcs1v15_512() {
    println("Testing verify_sha256_pkcs1v15 with inputs:");
    println(
        "Original Message: 'About ready south environment second finally. Work agency determine chance mean serve.'"
    );
    println(
        "Signature: 576745224752088557605724579075396240836094784473063860932429343679901243092360596350370941870180683657680865188551095458429546150960618883576826751753989"
    );
    println("e: 65537");
    println(
        "N: 7451117485959741229136504235315630995445254998446480425768448033902713699576518667817925145617353711577597420279881950650483923658530991624401513418271573"
    );

    let msg_hash = BigUint56 {
        limbs: [
            60503723948323480, 54161298035806000, 27012600088414088, 24217061042254220, 3153799981, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    };

    let mut sha256_hash = [0 as u8; 32];
    for i in 0..32 {
        // Reverse
        sha256_hash[i] = msg_hash.to_bytes()[31 - i];
    }

    assert(
        verify_sha256_pkcs1v15(
            sha256_hash,
            BigUint56 {
        limbs: [
            55229751642955525, 3387357325282344, 55293647890923184, 39104415763957832, 1619665796174313, 58538917026121421, 42799083892223376, 55799955887110396, 864672920360232, 11,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    },
            BigUint56 {
        limbs: [
            65537, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0
        ]
    },
            BigUint56 {
        limbs: [
            58658486617058133, 60448007089510078, 38078312823104700, 21692380715596569, 47263115411407232, 21587213462559447, 635655787029941, 3458672493564279, 19225757176393417, 142,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    }
        )
    );
}

#[test]
fn test_verify_sha256_pkcs1v15_1024() {
    println("Testing verify_sha256_pkcs1v15 with inputs:");
    println("Original Message: 'Hello World! This is Noir-RSA'");
    println(
        "Signature: 77929134187608511922495239264200453516249189680211783157419138967626951463678384095540409755596022527110500588052868475990692956380263184337020353767554108632525056703455094349084868832834519825911531623507412532278652516715214908372427289788659924082086149173428600500839052600213260337159219251648111234888"
    );
    println("e: 65537");
    println(
        "N: 107289837545940078268745022404080197756713492641688496535588794073231113663754058018862686762411228470731274703520877348777567694438387351688322419762264406460523426827357314688051865748955987197068553714344169462788708049399769970047547738378550534865494278049193738022398562701983786771227004540503235555427"
    );

    let msg_hash = BigUint56 {
        limbs: [
            29636029255065861, 46812423590223476, 40450127092546179, 6361609190670304, 1540304444,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    };

    let mut sha256_hash = [0 as u8; 32];
    for i in 0..32 {
        // Reverse
        sha256_hash[i] = msg_hash.to_bytes()[31 - i];
    }

    assert(
        verify_sha256_pkcs1v15(
            sha256_hash,
            BigUint56 {
        limbs: [
            52699351496183624, 17771455121010615, 49063755282121017, 58725018367967356, 30796621791787255, 71906570538305769, 10033835225921801, 3172760871373640, 9879679016151843, 7464615765664296, 55037165752094182, 24496750827850630, 48098420900460930, 30494277915249809, 53717776553245340, 60269219491917225, 46338655272543168, 39005641200166269, 28409,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    },
            BigUint56 {
        limbs: [
            65537, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    },
            BigUint56 {
        limbs: [
            23944647189524579, 2377479367467350, 51889790167097321, 45754325570956426, 7539170698549470, 38151733067270068, 10260079579305465, 43948046548007008, 14482938005228145, 25760390074814999, 9306948946850793, 10803652404843950, 62082595630651852, 23928959166473012, 46036245438656197, 37735076269077262, 55366113425466493, 11878715390678999, 39113,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    }
        )
    );
}

#[test]

fn test_verify_sha256_pkcs1v15_2048() {
    println("Testing verify_sha256_pkcs1v15 with inputs:");
    println("Original Message: 'Hello World! This is Noir-RSA'");
    println(
        "Signature: 6577e82547817c2820cbb9cfbbdceebe892780d61e2ce6fca3d4ed78901b6002cbad818c800a3d99b9800d672eb47cbac673003edfbeaca16c9d57ad2456fcfe33160bbd078be440604926fff1ddafb1f11115b5dd02900cd02c51660a00c27ab6c1c419026465563e02044d7fa6a7427ea28542d3bf4c250050a6a7619a256693572538f2bfe05810bdee5ff690b4be97ee8f7b5295c1e321e5fc3c341fe921b360cbd3750a20b42a27c549d6bbdcb008d81753622a2336d1aee215c15ea0646ac08eb8d515c16e2d0f4124eefa2861643e9839de5e744ac58a255f920923c0c628de5046df862a0dad7a72bb6ee5af30a020b7dd62416354542cee1b4c57ba"
    );
    println("e: 65537");
    println(
        "N: aad5a3f234f97ce521f239206cb50c435ead7265d2b64fb6efd5715464122349e413ff1a4a28e62d4b9035b832bc607354dee811dcc0e0b37b57ad07f02c883c60f8d135a3756ee3c2554b38bccb0286f7ebbea2b498d56656a5db6462c327b0d4bc53460c883644c1a1986b5c1f1c1d0a6b4f3458fc23e496f2e1b783f0a72fbd78ae7c86778a581210993774820b7082dd55801a538e02ea06cc0e8655d56a3540206a12695f5b5e48bce753e86dd9cc2de7798277281d6222c6f326eedd327d3ab87c135cac40484cfb67dfa467c82a5a0da98aaeda69ac92858c78d9f3fa40bec0646e8879d86ae77e32582bf85a5095f4cc75db4010e8934d0454d7cad3"
    );

    let msg: [u8] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 32, 84, 104, 105, 115, 32, 105, 115, 32, 78, 111, 105, 114, 45, 82, 83, 65];
    let hash = sha256(msg);
    println(hash);
    let hash_biguint = BigUint56::from_sha256_hash(hash);
    println(hash_biguint.limbs);

    let mut sha256_hash = [0 as u8; 32];
    for i in 0..32 {
        // Reverse
        sha256_hash[i] = hash_biguint.to_bytes()[31 - i];
    }

    let sign_bytes: [u8] = [101, 119, 232, 37, 71, 129, 124, 40, 32, 203, 185, 207, 187, 220, 238, 190, 137, 39, 128, 214, 30, 44, 230, 252, 163, 212, 237, 120, 144, 27, 96, 2, 203, 173, 129, 140, 128, 10, 61, 153, 185, 128, 13, 103, 46, 180, 124, 186, 198, 115, 0, 62, 223, 190, 172, 161, 108, 157, 87, 173, 36, 86, 252, 254, 51, 22, 11, 189, 7, 139, 228, 64, 96, 73, 38, 255, 241, 221, 175, 177, 241, 17, 21, 181, 221, 2, 144, 12, 208, 44, 81, 102, 10, 0, 194, 122, 182, 193, 196, 25, 2, 100, 101, 86, 62, 2, 4, 77, 127, 166, 167, 66, 126, 162, 133, 66, 211, 191, 76, 37, 0, 80, 166, 167, 97, 154, 37, 102, 147, 87, 37, 56, 242, 191, 224, 88, 16, 189, 238, 95, 246, 144, 180, 190, 151, 238, 143, 123, 82, 149, 193, 227, 33, 229, 252, 60, 52, 31, 233, 33, 179, 96, 203, 211, 117, 10, 32, 180, 42, 39, 197, 73, 214, 187, 220, 176, 8, 216, 23, 83, 98, 42, 35, 54, 209, 174, 226, 21, 193, 94, 160, 100, 106, 192, 142, 184, 213, 21, 193, 110, 45, 15, 65, 36, 238, 250, 40, 97, 100, 62, 152, 57, 222, 94, 116, 74, 197, 138, 37, 95, 146, 9, 35, 192, 198, 40, 222, 80, 70, 223, 134, 42, 13, 173, 122, 114, 187, 110, 229, 175, 48, 160, 32, 183, 221, 98, 65, 99, 84, 84, 44, 238, 27, 76, 87, 186];

    let sign = BigUint56::from_bytes(sign_bytes);

    let pubkey_n_bytes: [u8] = [170, 213, 163, 242, 52, 249, 124, 229, 33, 242, 57, 32, 108, 181, 12, 67, 94, 173, 114, 101, 210, 182, 79, 182, 239, 213, 113, 84, 100, 18, 35, 73, 228, 19, 255, 26, 74, 40, 230, 45, 75, 144, 53, 184, 50, 188, 96, 115, 84, 222, 232, 17, 220, 192, 224, 179, 123, 87, 173, 7, 240, 44, 136, 60, 96, 248, 209, 53, 163, 117, 110, 227, 194, 85, 75, 56, 188, 203, 2, 134, 247, 235, 190, 162, 180, 152, 213, 102, 86, 165, 219, 100, 98, 195, 39, 176, 212, 188, 83, 70, 12, 136, 54, 68, 193, 161, 152, 107, 92, 31, 28, 29, 10, 107, 79, 52, 88, 252, 35, 228, 150, 242, 225, 183, 131, 240, 167, 47, 189, 120, 174, 124, 134, 119, 138, 88, 18, 16, 153, 55, 116, 130, 11, 112, 130, 221, 85, 128, 26, 83, 142, 2, 234, 6, 204, 14, 134, 85, 213, 106, 53, 64, 32, 106, 18, 105, 95, 91, 94, 72, 188, 231, 83, 232, 109, 217, 204, 45, 231, 121, 130, 119, 40, 29, 98, 34, 198, 243, 38, 238, 221, 50, 125, 58, 184, 124, 19, 92, 172, 64, 72, 76, 251, 103, 223, 164, 103, 200, 42, 90, 13, 169, 138, 174, 218, 105, 172, 146, 133, 140, 120, 217, 243, 250, 64, 190, 192, 100, 110, 136, 121, 216, 106, 231, 126, 50, 88, 43, 248, 90, 80, 149, 244, 204, 117, 219, 64, 16, 232, 147, 77, 4, 84, 215, 202, 211];

    let pubkey_n = BigUint56::from_bytes(pubkey_n_bytes);

    assert(
        verify_sha256_pkcs1v15(
            sha256_hash,
            sign,
            BigUint56 {
                limbs: [
                    65537, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0
                ]
            },
            pubkey_n
        )
    );
}


#[test]
fn test_verify_sha256_pkcs1v15_4096() {
    println("Testing verify_sha256_pkcs1v15 with inputs:");
    println("Original Message: 'Hello World! This is Noir-RSA'");
    println(
        "Signature: 74d8111043ce2adb6e475de6df2d7f9c9cfdd8d4a9bae30bd9a61940606854a37488633913e236919b1c6ec21ecec2cbe4b4f764f5f33611d2a2e7dc302ab37970251e0e2a26be97c1e2a330c97be310f2adc701181d4efae028063ad806baa0621caad29ca89642e1092ceccb4e34c083cddcae55d1fd2d1e9be47d166e979ef57a0a3d30de95e768eb92944ba386e7d16395ed668e52284cabc46d0fff84bab58d157c826d5fff3e0d69d72e4c8a98cd540427e09b417e716ada48afaf6d48a092c6a0bad28b42ed953a1b75852fa567c04c4b1b9c0293be14103605843202051c45c851f5a3bf988f47a7b52696bc2fee5a1f941201ac46a8793103d111bcaf88b4e23186bcf0dd40e5e2fe95c7a4d600f8a638b0838cfd16cbfbd9dc61f773e394dd2e27ac8208b9e252e75f1381a88b3f82de671d730247f42a5a2ac377eb4161aa6e54177bdd6a5a132c6b350d5305a5525fa67363f5c093a4702f1e35d00a3cc79527c99dc9f96d0e5c6c2e44829edb2520203b636265e1c420cfc05d2fa9c9b15a5ade295d9d010658fd51d916c7b3e808d10439c974ebf3af8fe3c3eb374af0fa3e8fdea4a6ef73313385c308d2829a464014f335b5dc25b81b97a82b655a7e17522f7946423dba7421ae01e8845e69f30514434946602fd83560ca5d416b10304b6a526f6f1f9e0bfa104c58a6263a4be726f3f9ddfc9259ff9427"
    );
    println("e: 65537");
    println(
        "N: 9c10023a2f2339f5ac26654e58b9f62c4985505c64906ab3377159de38ec126cd2ee94c942f1870f7e09ad08300f138170d90fa9deab384057b56fdcb39ce9fa41ca0b8b7f8ec80c05df116e04951487f823d6dc1465d0796d8a3834388d2ebbe2a163c68a9975672b245b7e48db6bfc15c78869a98658a5fd8ad6bdea66ab357e8611dc73d61823d22ca442067955d8c8e3057d5a33a7a8f7568dd00231befd1bf4e0f1800aae1ceefe7dac27ec2467ea138cae6b20a316a4370f1ceee8f4674c83b7391d5866c330937a4d62249da6433b9cd3f909dc8c70b22718da133d5ac2ea96901b4cdfa338ca110351a97f8403986d080c430c5aeb25dea566fb61c7b97d398cdd55ef1a8cdf7e20a98f79abed2d6442556f9e17749b5044f3a03945e44967478b32570d335b7168e10f63d49edaa145db9b41733f98e18a622565d707161af15ed878b851bb87c70e832c3e65cee3aaa5a1eafa2a1877808fb3b600210a93c3207ab5e7608c415da93fcdfd02a6d413b0f89a5ef7434fd160bc871482fde264bc6bf7ba256ae857fb0a69e2d7f27867573ee15c2dec28dc1e1b74470853871c87375b4e0b272c15a1e6fcf064cc70455f1b0c89b7cc6e6a8a088c67bc02153c0ab284bcd5b46f7430429262c0f73b6b3ed5e39b5896a99d445b8c8a26fe3e435f8c265752424823eee9fb149eadf1adf29170c4cca384a740e52d83"
    );

    let msg_hash = BigUint56 {
        limbs: [
            29636029255065861, 46812423590223476, 40450127092546179, 6361609190670304, 1540304444,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0
        ]
    };

    let mut sha256_hash = [0 as u8; 32];
    for i in 0..32 {
        // Reverse
        sha256_hash[i] = msg_hash.to_bytes()[31 - i];
    }

    let sign_bytes: [u8] = [116, 216, 17, 16, 67, 206, 42, 219, 110, 71, 93, 230, 223, 45, 127, 156, 156, 253, 216, 212, 169, 186, 227, 11, 217, 166, 25, 64, 96, 104, 84, 163, 116, 136, 99, 57, 19, 226, 54, 145, 155, 28, 110, 194, 30, 206, 194, 203, 228, 180, 247, 100, 245, 243, 54, 17, 210, 162, 231, 220, 48, 42, 179, 121, 112, 37, 30, 14, 42, 38, 190, 151, 193, 226, 163, 48, 201, 123, 227, 16, 242, 173, 199, 1, 24, 29, 78, 250, 224, 40, 6, 58, 216, 6, 186, 160, 98, 28, 170, 210, 156, 168, 150, 66, 225, 9, 44, 236, 203, 78, 52, 192, 131, 205, 220, 174, 85, 209, 253, 45, 30, 155, 228, 125, 22, 110, 151, 158, 245, 122, 10, 61, 48, 222, 149, 231, 104, 235, 146, 148, 75, 163, 134, 231, 209, 99, 149, 237, 102, 142, 82, 40, 76, 171, 196, 109, 15, 255, 132, 186, 181, 141, 21, 124, 130, 109, 95, 255, 62, 13, 105, 215, 46, 76, 138, 152, 205, 84, 4, 39, 224, 155, 65, 126, 113, 106, 218, 72, 175, 175, 109, 72, 160, 146, 198, 160, 186, 210, 139, 66, 237, 149, 58, 27, 117, 133, 47, 165, 103, 192, 76, 75, 27, 156, 2, 147, 190, 20, 16, 54, 5, 132, 50, 2, 5, 28, 69, 200, 81, 245, 163, 191, 152, 143, 71, 167, 181, 38, 150, 188, 47, 238, 90, 31, 148, 18, 1, 172, 70, 168, 121, 49, 3, 209, 17, 188, 175, 136, 180, 226, 49, 134, 188, 240, 221, 64, 229, 226, 254, 149, 199, 164, 214, 0, 248, 166, 56, 176, 131, 140, 253, 22, 203, 251, 217, 220, 97, 247, 115, 227, 148, 221, 46, 39, 172, 130, 8, 185, 226, 82, 231, 95, 19, 129, 168, 139, 63, 130, 222, 103, 29, 115, 2, 71, 244, 42, 90, 42, 195, 119, 235, 65, 97, 170, 110, 84, 23, 123, 221, 106, 90, 19, 44, 107, 53, 13, 83, 5, 165, 82, 95, 166, 115, 99, 245, 192, 147, 164, 112, 47, 30, 53, 208, 10, 60, 199, 149, 39, 201, 157, 201, 249, 109, 14, 92, 108, 46, 68, 130, 158, 219, 37, 32, 32, 59, 99, 98, 101, 225, 196, 32, 207, 192, 93, 47, 169, 201, 177, 90, 90, 222, 41, 93, 157, 1, 6, 88, 253, 81, 217, 22, 199, 179, 232, 8, 209, 4, 57, 201, 116, 235, 243, 175, 143, 227, 195, 235, 55, 74, 240, 250, 62, 143, 222, 164, 166, 239, 115, 49, 51, 133, 195, 8, 210, 130, 154, 70, 64, 20, 243, 53, 181, 220, 37, 184, 27, 151, 168, 43, 101, 90, 126, 23, 82, 47, 121, 70, 66, 61, 186, 116, 33, 174, 1, 232, 132, 94, 105, 243, 5, 20, 67, 73, 70, 96, 47, 216, 53, 96, 202, 93, 65, 107, 16, 48, 75, 106, 82, 111, 111, 31, 158, 11, 250, 16, 76, 88, 166, 38, 58, 75, 231, 38, 243, 249, 221, 252, 146, 89, 255, 148, 39];

    let sign = BigUint56::from_bytes(sign_bytes);

    let pubkey_n_bytes: [u8] = [156, 16, 2, 58, 47, 35, 57, 245, 172, 38, 101, 78, 88, 185, 246, 44, 73, 133, 80, 92, 100, 144, 106, 179, 55, 113, 89, 222, 56, 236, 18, 108, 210, 238, 148, 201, 66, 241, 135, 15, 126, 9, 173, 8, 48, 15, 19, 129, 112, 217, 15, 169, 222, 171, 56, 64, 87, 181, 111, 220, 179, 156, 233, 250, 65, 202, 11, 139, 127, 142, 200, 12, 5, 223, 17, 110, 4, 149, 20, 135, 248, 35, 214, 220, 20, 101, 208, 121, 109, 138, 56, 52, 56, 141, 46, 187, 226, 161, 99, 198, 138, 153, 117, 103, 43, 36, 91, 126, 72, 219, 107, 252, 21, 199, 136, 105, 169, 134, 88, 165, 253, 138, 214, 189, 234, 102, 171, 53, 126, 134, 17, 220, 115, 214, 24, 35, 210, 44, 164, 66, 6, 121, 85, 216, 200, 227, 5, 125, 90, 51, 167, 168, 247, 86, 141, 208, 2, 49, 190, 253, 27, 244, 224, 241, 128, 10, 174, 28, 238, 254, 125, 172, 39, 236, 36, 103, 234, 19, 140, 174, 107, 32, 163, 22, 164, 55, 15, 28, 238, 232, 244, 103, 76, 131, 183, 57, 29, 88, 102, 195, 48, 147, 122, 77, 98, 36, 157, 166, 67, 59, 156, 211, 249, 9, 220, 140, 112, 178, 39, 24, 218, 19, 61, 90, 194, 234, 150, 144, 27, 76, 223, 163, 56, 202, 17, 3, 81, 169, 127, 132, 3, 152, 109, 8, 12, 67, 12, 90, 235, 37, 222, 165, 102, 251, 97, 199, 185, 125, 57, 140, 221, 85, 239, 26, 140, 223, 126, 32, 169, 143, 121, 171, 237, 45, 100, 66, 85, 111, 158, 23, 116, 155, 80, 68, 243, 160, 57, 69, 228, 73, 103, 71, 139, 50, 87, 13, 51, 91, 113, 104, 225, 15, 99, 212, 158, 218, 161, 69, 219, 155, 65, 115, 63, 152, 225, 138, 98, 37, 101, 215, 7, 22, 26, 241, 94, 216, 120, 184, 81, 187, 135, 199, 14, 131, 44, 62, 101, 206, 227, 170, 165, 161, 234, 250, 42, 24, 119, 128, 143, 179, 182, 0, 33, 10, 147, 195, 32, 122, 181, 231, 96, 140, 65, 93, 169, 63, 205, 253, 2, 166, 212, 19, 176, 248, 154, 94, 247, 67, 79, 209, 96, 188, 135, 20, 130, 253, 226, 100, 188, 107, 247, 186, 37, 106, 232, 87, 251, 10, 105, 226, 215, 242, 120, 103, 87, 62, 225, 92, 45, 236, 40, 220, 30, 27, 116, 71, 8, 83, 135, 28, 135, 55, 91, 78, 11, 39, 44, 21, 161, 230, 252, 240, 100, 204, 112, 69, 95, 27, 12, 137, 183, 204, 110, 106, 138, 8, 140, 103, 188, 2, 21, 60, 10, 178, 132, 188, 213, 180, 111, 116, 48, 66, 146, 98, 192, 247, 59, 107, 62, 213, 227, 155, 88, 150, 169, 157, 68, 91, 140, 138, 38, 254, 62, 67, 95, 140, 38, 87, 82, 66, 72, 35, 238, 233, 251, 20, 158, 173, 241, 173, 242, 145, 112, 196, 204, 163, 132, 167, 64, 229, 45, 131];

    let pubkey_n = BigUint56::from_bytes(pubkey_n_bytes);

    assert(
        verify_sha256_pkcs1v15(
            sha256_hash,
            sign,
            BigUint56 {
                limbs: [
                    65537, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                    0, 0, 0, 0, 0, 0, 0
                ]
            },
            pubkey_n
        )
    );
}